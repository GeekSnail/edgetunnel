# This is a basic workflow to help you get started with Actions

name: test

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  #push:
  #  branches: [ "main" ]
  #pull_request:
  #  branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      json:
        description: "json content"
        required: false
        default: ""
        type: "string"
      ip:
        description: "proxy ip"
        required: false
        default: ""
        type: "string"
      domain:
        description: "lookup domain"
        required: false
        default: ""
        type: "string"

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      - name: comm test
        run: |
          comm --help
          echo -ne 'c.com\na.com\nb.com\n' > l.txt
          echo -ne 'd.com\nc.com\n' > r.txt
          echo ----l.txt----
          cat l.txt
          echo ----r.txt----
          cat r.txt
          echo ----comm----
          comm -23 <(sort l.txt) <(sort r.txt)
          echo '----comm >----'
          comm -23 <(sort l.txt) <(sort r.txt) > t.txt
          mv t.txt l.txt
          echo ----l.txt----
          cat l.txt

      - name: inputs json test
        if: ${{inputs.json != ''}}
        run: |
          # https://stackoverflow.com/questions/46954692/check-if-string-is-a-valid-json-with-jq
          echo '${{ inputs.json }}' | jq -e . >/dev/null
          jq -e . >/dev/null <<< '${{ inputs.json }}'
          echo '${{ inputs.json }}' > test.json
          cat test.json
          jq --help

      - name: curl proxy test
        if: ${{inputs.ip != ''}}
        run: |
          set +e
          bc --help
          host1='speed.cloudflare.com'; path1='/cdn-cgi/trace'
          host2='android.chat.openai.com'; path2='/public-api/mobile/server_status/v1'
          curl http://ip.sb
          for ip in ${{ inputs.ip }}; do
            echo ip=$ip
            if curl -so /dev/null -I --connect-timeout 5 --resolve $host1:443:$ip https://$host1$path1; then
              r=`curl -s -w '\n%{http_code}' --connect-timeout 5 --retry 1 --resolve $host2:443:$ip https://$host2$path2`
              echo $? $r;
            fi
          done
          echo 'finished'

      - name: setup node
        if: ${{inputs.domain != ''}}
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: dig test
        if: ${{inputs.domain != ''}}
        run: |
          dig -h

          for d in ${{ inputs.domain }}; do
            echo dig $d ......
            echo ----short----
            ip=$(dig +short @1.1.1.1 $d | grep -v '\.$' | head -n1)
            [ ! -z "$ip" ] && echo $d $ip | tee -a tocheck.txt
          done
          [ ! -f tocheck.txt ] && exit 0

          [ -f src/cfcidr.js ] && mv src/cfcidr.js src/cfcidr.mjs
          cat > checkip.mjs <<-EOF
          import fs from 'node:fs';
          import readline from 'node:readline';
          import inCfSubNet from './cfcidr.mjs';

          async function processLine(filename) {
            const fileStream = fs.createReadStream(filename);
            const rl = readline.createInterface({
              input: fileStream,
              crlfDelay: Infinity,
            });
            for await (const line of rl) {
              const [d,ip] = line.split(' ')
              ip && inCfSubNet(ip) && console.log(d);
            }
          }
          processLine(process.argv[2]);
          EOF

          node checkip.mjs tocheck.txt > cf.txt
          echo -------------------------
          cat cf.txt
