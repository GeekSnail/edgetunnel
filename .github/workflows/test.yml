# This is a basic workflow to help you get started with Actions

name: test

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  #push:
  #  branches: [ "main" ]
  #pull_request:
  #  branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      json:
        description: "json content"
        required: false
        default: ""
        type: "string"
      ip:
        description: "proxy ip"
        required: false
        default: ""
        type: "string"
      domain:
        description: "lookup domain"
        required: false
        default: ""
        type: "string"
      kvKey:
        description: "kv namespace key"
        required: false
        default: ""
        type: "string"

env:
  multilines: "${{vars.MULTILINES}}"
  # CF_API_TOKEN: ${{secrets.CF_API_TOKEN}}
  # CF_KV_API: https://api.cloudflare.com/client/v4/accounts/${{secrets.CF_ACCOUNT_ID}}/storage/kv/namespaces/${{secrets.CF_NAMESPACE_ID || vars.CF_NAMESPACE_ID}}/values
  EVENT_NAME: ${{github.event_name}}
  SCHEDULE: ${{github.event.schedule}}

  CF_ACCOUNT_ID: ${{secrets.CF_ACCOUNT_ID}}
  CF_KV_API: https://api.cloudflare.com/client/v4/accounts/${{secrets.CF_ACCOUNT_ID}}/storage/kv/namespaces/${{secrets.CF_NAMESPACE_ID || vars.CF_NAMESPACE_ID}}/values
  CF_API_TOKEN: ${{secrets.CF_API_TOKEN}}
  CF_NAMESPACE_ID: ${{secrets.CF_NAMESPACE_ID || vars.CF_NAMESPACE_ID}}
  
  CFHOST: cfhost
  CFHOST_BAK: cfhost_bak
  CFHOST_JSON: src/cfhost.json
  CFHOSTPAT_JS: src/cfhostpat.js
  CFHOSTPAT_JSON: src/cfhostpat.json
  PROXYS: proxys
  PROXYS_UPDATED: proxys_updated
  PROXYS_JSON: src/proxys.json
  ENTRY: dist/_worker.js
  UUID: UUID
  KV: KV


# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      - id: check-cfhost
        name: check cfhost, merge, backup
        run: |
          [ -z ${{secrets.CF_ACCOUNT_ID}} ] || [ -z $CF_API_TOKEN ] || [ -z $CF_NAMESPACE_ID ] && echo "secrets and CF_NAMESPACE_ID required!" && exit 1;
          . .github/common.sh
          touch remote.txt

          check_backup(){
            if once_week; then
              echo check $CFHOSTPAT_JSON ...
              node $CFHOSTPAT_JS toLines > pat.txt
              filterhost pat.txt handlePat
            fi
            
            json_array_tolines $CFHOST_JSON > local.txt
            echo "$CFHOST_JSON - `wc -l local.txt`" >> $GITHUB_STEP_SUMMARY
            if [ -s local.txt ] && once_day; then
              echo check $CFHOST_JSON ...
              filterhost local.txt > tmp
              [ ! -s tmp ] && echo 'maybe filterhost error!' && exit 1
              file_lines_tojson tmp > $CFHOST_JSON
              mv tmp local.txt
              echo "filter, `wc -l local.txt`" >> $GITHUB_STEP_SUMMARY
            fi
            
            local ret=`curl -H "Authorization:Bearer $CF_API_TOKEN" "$CF_KV_API/$CFHOST"`
            if echo "$ret"|grep error; then
              grep 'namespace not found' <<< "$ret" && exit 1 || echo "$ret"
            elif [ ! -z "$ret" ] && [ "$ret" != "[]" ]; then
              json_array_tolines $ret > remote.txt
              echo "get kv $CFHOST, `wc -l remote.txt`" >> $GITHUB_STEP_SUMMARY
              
              local bak=`curl -H "Authorization:Bearer $CF_API_TOKEN" "$CF_KV_API/$CFHOST_BAK"`
              if ! echo "$bak"|grep error && [ ! -z "$bak" ] && [ "$bak" != "[]" ]; then
                json_array_tolines $bak >> remote.txt
                sort -uo remote.txt remote.txt
                echo "get kv $CFHOST_BAK, merge, `wc -l remote.txt`" >> $GITHUB_STEP_SUMMARY
              fi
                
              #diff -b --suppress-common-lines remote.txt local.txt | grep '<' | sed 's/< *//' > remote.txt
              comm -23 <(sort remote.txt) <(sort local.txt) > tmp && mv tmp remote.txt
              # diff after manually update cfhostpat.json
              echo "diff $CFHOSTPAT_JSON ..."
              local pat=`node $CFHOSTPAT_JS cfhostRE|sed -r 's|^/(.*)/$|\1|'`
              while read -r d; do
                [[ $d =~ $pat ]] && sed -i '/'$d'/d' remote.txt && echo delete $d from remote.txt
              done < remote.txt
              echo "diff local, `wc -l remote.txt`" >> $GITHUB_STEP_SUMMARY
              
              if [ -s remote.txt ]; then
                filterhost remote.txt > tmp && mv tmp remote.txt
                echo "filter, `wc -l remote.txt`" >> $GITHUB_STEP_SUMMARY
              fi
              ret=`file_lines_tojson remote.txt`
              [ "$ret" != "$bak" ] && echo "kvCfhostChanged=true" >> $GITHUB_ENV;
            
              bak=`file_lines_tojson remote.txt`
              echo $bak
            fi
          }
          check_backup

      - name: kv test
        if: ${{inputs.kvKey != ''}}
        run: |
          ret=`curl -H "Authorization:Bearer $CF_API_TOKEN" "$CF_KV_API/${{inputs.kvKey}}"`
          echo ${{inputs.kvKey}}=$ret.

      - name: action test
        run: |
          echo ----multilines vars----
          echo '${{vars.MULTILINES}}'
          echo ----
          echo "$multilines"
          TZ="Asia/Shanghai" date

      - name: comm test
        run: |
          comm --help
          echo -ne 'c.com\na.com\nb.com\n' > l.txt
          echo -ne 'd.com\nc.com\n' > r.txt
          echo ----l.txt----
          cat l.txt
          echo ----r.txt----
          cat r.txt
          echo ----comm----
          comm -23 <(sort l.txt) <(sort r.txt)
          echo '----comm >----'
          comm -23 <(sort l.txt) <(sort r.txt) > t.txt
          mv t.txt l.txt
          echo ----l.txt----
          cat l.txt

      - name: inputs json test
        if: ${{inputs.json != ''}}
        run: |
          # https://stackoverflow.com/questions/46954692/check-if-string-is-a-valid-json-with-jq
          echo '${{ inputs.json }}' | jq -e . >/dev/null
          jq -e . >/dev/null <<< '${{ inputs.json }}'
          echo '${{ inputs.json }}' > test.json
          cat test.json
          jq --help

      - name: curl proxy test
        if: ${{inputs.ip != ''}}
        run: |
          set +e
          bc --help
          host1='speed.cloudflare.com'; path1='/cdn-cgi/trace'
          host2='android.chat.openai.com'; path2='/public-api/mobile/server_status/v1'
          curl http://ip.sb
          for ip in ${{ inputs.ip }}; do
            echo ip=$ip
            if curl -so /dev/null -I --connect-timeout 5 --resolve $host1:443:$ip https://$host1$path1; then
              r=`curl -s -w '\n%{http_code}' --connect-timeout 5 --retry 1 --resolve $host2:443:$ip https://$host2$path2`
              echo $? $r;
            fi
          done
          echo 'finished'

      - name: setup node
        if: ${{inputs.domain != ''}}
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: dig test
        if: ${{inputs.domain != ''}}
        run: |
          cat /etc/resolv.conf
          for d in ${{ inputs.domain }}; do
            echo dig $d ...
            dig $d
            dig $d @8.8.8.8
            dig $d @223.5.5.5
            dig $d @76.76.2.0
            dig $d @208.67.222.222
            echo nslookup $d ...
            nslookup $d
            nslookup $d 8.8.8.8
            nslookup $d 223.5.5.5
            nslookup $d 76.76.2.0
            nslookup $d 208.67.222.222
          done
          # echo ----ipv6----
          # for d in ${{ inputs.domain }}; do
          #   echo dig $d ...
          #   dig $d @2400:3200::1
          #   dig $d @2001:4860:4860::8888
          #   dig $d @2606:1a40::
          #   dig $d @2620:119:35::35
          #   dig $d @2606:4700:4700::1111
          #   dig $d @2a10:50c0::ad1:ff
          #   echo nslookup $d ...
          #   nslookup $d 2400:3200::1
          #   nslookup $d 2001:4860:4860::8888
          #   nslookup $d 2606:1a40::
          #   nslookup $d 2620:119:35::35
          #   nslookup $d 2606:4700:4700::1111
          #   nslookup $d 2a10:50c0::ad1:ff
          # done

          echo ----trace----
          for d in ${{ inputs.domain }}; do
            echo dig $d ...
            dig $d +trace
            dig $d @223.5.5.5 +trace
          done
